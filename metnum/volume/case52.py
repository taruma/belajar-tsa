# -*- coding: utf-8 -*-

import numpy as np
import matplotlib.pyplot as plt
import argparse
from numpy import exp
from case42 import create_zmatrix, create_axis

def parse_command_line():
    """
    Parse the command line arguments and return the parse_args object.
    
    There are 2 optional arguments.
    The help message generated by the parser should look like:
    
    usage: case42.py    [-h] [-n]

    optional arguments:
      -h, --help            show this help message and exit
      -n, --nodes           nodes (positive integer)
      -c1, --case1          show only case 1
      -c2, --case2          show only case 2

    args:
        None
        
    returns:
        args: generated argparse object with all the passed command line arguments      
    """
    parser = argparse.ArgumentParser()

    # Optional Argument
    parser.add_argument('-n', '--nodes', metavar='nodes', type=int, 
                        default=5, help='nodes (positive integer)')
    parser.add_argument('-c1', '--case1', action='store_true', help='show only case 1')
    parser.add_argument('-c2', '--case2', action='store_true', help='show only case 2')
    
    return parser.parse_args()

def func_c1exact(x):
    x = np.array(x)
    return (2.7183-exp(x))/1.7183

def func_c2exact(x):
    return (1+(1-exp(25*x))/(7.2*10**10))

def set_var(L=1, rho=1, gamma=0.1, nodes=5):
    dx = L/nodes
    return {'L': L, 'rho': rho, 'gamma': gamma, 'nodes': nodes, 'dx': dx}

def set_case(u=0.1, D=0.5, gamma=0.1, rho=1, dx=0.2, phiA=1, phiB=0):
    F, D = rho*u, gamma/dx
    return {'u': u, 'F': F, 'D': D, 'gamma': gamma, 
            'rho': rho, 'dx': dx, 'phiA': phiA, 'phiB': phiB}

def equation_nodes(direction, position, case):
    keys = ('F', 'D', 'phiA', 'phiB')
    F, D, phiA, phiB = [case[x] for x in keys]
    if direction:
        if position.lower() == 'mid':
            aW, aE = F + D, D
            SP = 0
            Su = 0
            aP = aW + aE + SP
            return aW, aP, aE, Su    
        elif position.lower() == 'left':
            aW, aE = 0, D
            SP = F + 2*D
            Su = (F+2*D)*phiA
            aP = aW + aE + SP
            return aW, aP, aE, Su
        elif position.lower() == 'right':
            aW, aE = F+D, 0
            SP = 2*D
            Su = 2*D*phiB
            aP = aW + aE + SP
            return aW, aP, aE, Su
    else:
        if position.lower() == 'mid':
            aW, aE = D, D-F
            SP = 0
            Su = 0
            aP = aW + aE + SP
            return aW, aP, aE, Su    
        elif position.lower() == 'left':
            aW, aE = 0, D-F
            SP = 2*D
            Su = phiA*(2*D)
            aP = aW + aE + SP
            return aW, aP, aE, Su
        elif position.lower() == 'right':
            aW, aE = D, 0
            SP = 2*D-F
            Su = phiB*(2*D-F)
            aP = aW + aE + SP
            return aW, aP, aE, Su
        
def calc_matrix(mat_a, mat_d, node_set, case):
    """
    Calculate matrix based on direction
    """
    F = case['F']
    direction = True if F >= 0 else False
    
    for i in range(0, nodes):
        for j in range(0, nodes):
            if i == j and i == 0:
                aW, aP, aE, Su = node_set(direction, 'left', case)
                mat_a[i, j] = aP
                mat_a[i, j+1] = -aE
                mat_d[i] = Su
            elif i == j and (i > 0 and i < nodes-1):
                aW, aP, aE, Su = node_set(direction, 'mid', case)
                mat_a[i, j-1] = -aW
                mat_a[i, j] = aP
                mat_a[i, j+1] = -aE
                mat_d[i] = Su
            elif i == j and (i == nodes-1):
                aW, aP, aE, Su = node_set(direction, 'right', case)
                mat_a[i, j-1] = -aW
                mat_a[i, j] = aP
                mat_d[i] = Su

def prep_y(matrix, case):
    A, B = case['phiA'], case['phiB']
    y_num = np.append(matrix, B)
    y_num = np.insert(y_num, 0, A)
    return y_num

def create_xy(func, L=1, n=50):
    x = np.linspace(0, L, n)
    y = func(x)
    return x, y

def calc_case(dictvar, dictcase, case=1):
    varkeys = ('dx', 'nodes', 'L', 'rho', 'gamma')
    dx, nodes, L, rho, gamma = map(dictvar.get, varkeys)

    # Buat Matrix
    mat_a, mat_d = create_zmatrix(nodes)
    calc_matrix(mat_a, mat_d, equation_nodes, dictcase)
    mat_x = np.linalg.solve(mat_a, mat_d)    

    # Buat x, y numerical
    x_num = create_axis(nodes, L)
    y_num = prep_y(mat_x, dictcase)
    
    # Exact Solution
    if case == 1:
        func = func_c1exact
        x_exact, y_exact = create_xy(func, L=L)
    elif case == 2:
        func = func_c2exact
        x_exact, y_exact = create_xy(func, L=L)
    else:
        x_exact, y_exact = 0, 0
    
    return (x_num, y_num), (x_exact, y_exact)

def plot_this(num, x1, y1, x2, y2, title=''):
    plt.figure(num)
    plt.title(title)
    plt.xlabel('Distance x (m)')
    plt.ylabel('$\phi$')
    plt.plot(x1, y1, 'bo', label='numerical')
    plt.plot(x2, y2, 'y--', label='analytical')
    plt.legend()
    plt.grid()
    #plt.show()
    
def calc_error(var, sol_num, func, title='Percentage Error',
               kolom=15, prec=6):
    nodes, L = var['nodes'], var['L']
    
    node = np.arange(1, nodes+1)
    distance = create_axis(nodes, L)[1:-1]
    sol_exact = func(distance)
    sol_num = sol_num[1:-1]
    
    diff, percenterr = [], []
    for i, val in enumerate(sol_exact):
        dval = val - sol_num[i]
        diff.append(dval)
        percenterr.append(dval/val*100)
    
    lebar = kolom*6+7
    print('='*lebar)
    print('{:^{l:d}s}'.format(title, l=lebar))
    print('='*lebar)
    print('|{:^{k:d}s}|{:^{k:d}s}|{:^{k:d}s}|{:^{k:d}s}|{:^{k:d}s}|{:^{k:d}s}|'.format(
            'node', 'distance', 'numeric', 'exact', 'diff', 'error', k=kolom))
    print('-'*lebar)
    
    for i in range(0, nodes):
        print('| {:^{k:d}d} | {:> {k:d}.{p:d}f} | {:> {k:d}.{p:d}f} | {:> {k:d}.{p:d}f} | {:> {k:d}.{p:d}f} | {:> {k:d}.{p:d}f} |'.format(
                node[i], distance[i], sol_num[i], sol_exact[i], diff[i], percenterr[i], k=kolom-2, p=prec
                ))
    print('='*lebar)
    
def print_info(var, case, title='Case', kolom=20):
    def print_desc(desc, val, unit):
        print('| {:<{k:d}s} | {:> {k:d}f} | {:^{k:d}s} |'.format(
                desc, val, unit, k=kolom-2))
    
    lebar = kolom*3+4
    print('='*lebar)
    print('|{:^{l:d}s}|'.format(title, l=lebar-2))
    print('='*lebar)
    print('|{:^{k:d}s}|{:^{k:d}s}|{:^{k:d}s}|'.format('description', 'value', 'unit', k=kolom))
    print('-'*lebar)
    
    nodes, rho, gamma, dx, L = map(var.get, ('nodes', 'rho', 'gamma', 'dx', 'L'))
    u, F, D = map(case.get, ('u', 'F', 'D'))
    
    print_desc('\\rho', rho, 'kg/(m^3)')
    print_desc('\\gamma', gamma, 'kg/(m.s)')
    print_desc('L', L, 'm')
    print_desc('nodes', nodes, '-')
    print_desc('dx', dx, 'm')
    print('-'*lebar)
    print_desc('u', u, 'm/s')
    print_desc('F', F, '-')
    print_desc('D', D, '-')
    print('='*lebar)
    print()

# MAIN PROGRAM Here
if __name__ == '__main__':
    args = parse_command_line()
    var = set_var(nodes=args.nodes)
    dx, rho, gamma, nodes = var['dx'], var['rho'], var['gamma'], var['nodes']
    
    check = True if not ((args.case1) or (args.case2)) else False
    
    if args.case1 or check:
        case1 = set_case(u=0.1, dx=dx, rho=rho, gamma=gamma)
        print_info(var, case1, title='Case 1')
        (x1, y1), (x2, y2) = calc_case(var, case1, 1)
        calc_error(var, y1, func_c1exact, title='Percentage Error Case 1')
        plot_this(1, x1, y1, x2, y2, 'case 1 $u = 0.1$')
    
    print('\n'*2)
    
    if args.case2 or check:
        case2 = set_case(u=2.5, dx=dx, rho=rho, gamma=gamma)
        print_info(var, case2, title='Case 2')
        (x1, y1), (x2, y2) = calc_case(var, case2, 2)
        calc_error(var, y1, func_c2exact, title='Percentage Error Case 2')
        plot_this(2, x1, y1, x2, y2, 'case 2 $u = 2.5$')
    plt.show()