# -*- coding: utf-8 -*-

import numpy as np
import matplotlib.pyplot as plt
import argparse
from numpy import exp
from case42 import create_zmatrix, create_axis


def parse_command_line():
    """
    Parse the command line arguments and return the parse_args object.
    
    There are 2 optional arguments.
    The help message generated by the parser should look like:
    
    usage: case42.py    [-h] [-n]

    optional arguments:
      -h, --help            show this help message and exit
      -n, --nodes           nodes (positive integer)

    args:
        None
        
    returns:
        args: generated argparse object with all the passed command line arguments      
    """
    parser = argparse.ArgumentParser()

    # Optional Argument
    parser.add_argument('-n', '--nodes', metavar='nodes', type=int, 
                        default=5, help='nodes (positive integer)')
    return parser.parse_args()

def func_c1exact(x):
    x = np.array(x)
    return (2.7183-exp(x))/1.7183

def func_c2exact(x):
    return (1+(1-exp(25*x))/(7.2*10**10))

def set_var(L=1, rho=1, gamma=0.1, nodes=5):
    dx = L/nodes
    return {'L': L, 'rho': rho, 'gamma': gamma, 'nodes': nodes, 'dx': dx}

def set_case(u=0.1, D=0.5, gamma=0.1, rho=1, dx=0.2, phiA=1, phiB=0):
    F, D = rho*u, gamma/dx
    return {'u': u, 'F': F, 'D': D, 'gamma': gamma, 
            'rho': rho, 'dx': dx, 'phiA': phiA, 'phiB': phiB}

def equation_nodes(direction, position, case):
    keys = ('F', 'D', 'phiA', 'phiB')
    F, D, phiA, phiB = [case[x] for x in keys]
    if direction:
        if position.lower() == 'mid':
            aW, aE = F + D, D
            SP = 0
            Su = 0
            aP = aW + aE + SP
            return aW, aP, aE, Su    
        elif position.lower() == 'left':
            aW, aE = 0, D
            SP = F + 2*D
            Su = (F+2*D)*phiA
            aP = aW + aE + SP
            return aW, aP, aE, Su
        elif position.lower() == 'right':
            aW, aE = F+D, 0
            SP = 2*D
            Su = 2*D*phiB
            aP = aW + aE + SP
            return aW, aP, aE, Su
    else:
        if position.lower() == 'mid':
            aW, aE = D, D-F
            SP = 0
            Su = 0
            aP = aW + aE + SP
            return aW, aP, aE, Su    
        elif position.lower() == 'left':
            aW, aE = 0, D-F
            SP = 2*D
            Su = phiA*(2*D)
            aP = aW + aE + SP
            return aW, aP, aE, Su
        elif position.lower() == 'right':
            aW, aE = D, 0
            SP = 2*D-F
            Su = phiB*(2*D-F)
            aP = aW + aE + SP
            return aW, aP, aE, Su
        
def calc_matrix(mat_a, mat_d, node_set, case):
    """
    Calculate matrix based on direction
    """
    F = case['F']
    direction = True if F >= 0 else False
    
    for i in range(0, nodes):
        for j in range(0, nodes):
            if i == j and i == 0:
                aW, aP, aE, Su = node_set(direction, 'left', case)
                mat_a[i, j] = aP
                mat_a[i, j+1] = -aE
                mat_d[i] = Su
            elif i == j and (i > 0 and i < nodes-1):
                aW, aP, aE, Su = node_set(direction, 'mid', case)
                mat_a[i, j-1] = -aW
                mat_a[i, j] = aP
                mat_a[i, j+1] = -aE
                mat_d[i] = Su
            elif i == j and (i == nodes-1):
                aW, aP, aE, Su = node_set(direction, 'right', case)
                mat_a[i, j-1] = -aW
                mat_a[i, j] = aP
                mat_d[i] = Su

def prep_y(matrix, case):
    A, B = case['phiA'], case['phiB']
    y_num = np.append(matrix, B)
    y_num = np.insert(y_num, 0, A)
    return y_num

def create_xy(func, L=1, n=50):
    x = np.linspace(0, L, n)
    y = func(x)
    return x, y

def calc_case(dictvar, dictcase, case=1):
    varkeys = ('dx', 'nodes', 'L', 'rho', 'gamma')
    dx, nodes, L, rho, gamma = map(dictvar.get, varkeys)

    # Buat Matrix
    mat_a, mat_d = create_zmatrix(nodes)
    calc_matrix(mat_a, mat_d, equation_nodes, dictcase)
    mat_x = np.linalg.solve(mat_a, mat_d)    

    # Buat x, y numerical
    x_num = create_axis(nodes, L)
    y_num = prep_y(mat_x, dictcase)
    
    # Exact Solution
    if case == 1:
        func = func_c1exact
        x_exact, y_exact = create_xy(func, L=L)
    elif case == 2:
        func = func_c2exact
        x_exact, y_exact = create_xy(func, L=L)
    else:
        x_exact, y_exact = 0, 0
    
    return (x_num, y_num), (x_exact, y_exact)

def plot_this(num, x1, y1, x2, y2, title=''):
    plt.figure(num)
    plt.title(title)
    plt.xlabel('Distance x (m)')
    plt.ylabel('$\phi$')
    plt.plot(x1, y1, 'bo', label='numerical')
    plt.plot(x2, y2, 'y--', label='analytical')
    plt.legend()
    plt.grid()
    plt.show()
    
def print_error(y_num, y_exact):
    for counter, val in enumerate(y_num):
        hasil = (y_exact[counter] - val)/val*100
        print('Percentage Error pada titik {:3d} = {:2.2f}'.format(counter, hasil))

# PROGRAM Here
if __name__ == '__main__':
    args = parse_command_line()
    nodes = args.nodes
    var = set_var(nodes=nodes)
    dx, rho, gamma = var['dx'], var['rho'], var['gamma']
    
    case1 = set_case(u=0.1, dx=dx, rho=rho, gamma=gamma)
    (x1, y1), (x2, y2) = calc_case(var, case1, 1)
    plot_this(1, x1, y1, x2, y2, 'case 1 $u = 0.1$')
    
    case2 = set_case(u=2.5, dx=dx, rho=rho, gamma=gamma)
    (x1, y1), (x2, y2) = calc_case(var, case2, 2)
    plot_this(2, x1, y1, x2, y2, 'case 2 $u = 2.5$')